[
  {
    "objectID": "importing_data.html",
    "href": "importing_data.html",
    "title": "Importing and formatting data",
    "section": "",
    "text": "Get familiar with the basic input data format\nKnow the main functions to import data and format it"
  },
  {
    "objectID": "importing_data.html#setting-the-working-directory",
    "href": "importing_data.html#setting-the-working-directory",
    "title": "Importing and formatting data",
    "section": "2.1 Setting the working directory",
    "text": "2.1 Setting the working directory\nTo read data in R you need to specify the working directory. It can be set with the function setwd(). The way you do this depends on the operating system (windows, mac, Linux). The folder directory syntax follows the nested structure of the folders. For instance:\n\n\nCode\nsetwd(\"/home/m/Desktop/\")\n\n\n… sets the working directory in the folder “Desktop”, which is found within “m”, which is found within “home”.\n \nSome basic tips for setting the working directory:\n\nMake sure the location is quoted\nMake sure you have forward-slash (/) between folder names (although double backward-slashes seem to work in windows)\nDo not include any file name in the folder directory name\nTo find the location you can look at the properties of a file in that folder and copy it\nThe path to the folder should be quoted (““)\nThe name matches exactly (better to copy/paste)\nUse list.files() to check which files are in the working directory\nR can suggest and auto-complete the folder names by pressing “tab” when within quotes:\n\n \n\n \nSetting the working directory in windows\nIn windows it should be something like this:\n\n\nCode\nsetwd(\"C:/location\")\n\n\nYou can also do this (only on windows!):\n\n\nCode\nsetwd(choose.dir())\n\n\n  That should pop-up a window where you can choose the location. However, this should only be used to figure out the correct way to write the directory location, not as part of the script itself.\n \nSetting the working directory in OSX (mac)\nFor mac setting the working directory should be something like this:\n\n\nCode\nsetwd(\"/Users/yourname/..\")\n\n\ndo not include whatever you have before “users” (like macintosh… )\n \nSetting the working directory in Linux\nSimilar to the code used in OSX:\n\n\nCode\nsetwd(\"/home/m/Desktop/\")\n\n\n \nThe “~” (tilde) can also be used to skip the “home” and “user” folder in Linux:\n\n\nCode\nsetwd(\"~/Desktop/\")\n\n\n \nThe current working directory can be checked as follows:\n\n\nCode\ngetwd()\n\n\n[1] \"/home/marce/Dropbox/courses_and_workshops/estadistica/OTS_TBCP_2024\""
  },
  {
    "objectID": "importing_data.html#reading-data",
    "href": "importing_data.html#reading-data",
    "title": "Importing and formatting data",
    "section": "2.2 Reading data",
    "text": "2.2 Reading data\nAny file can be read in R. It’s just a matter of letting R know in which format is the file encoded (e.g. what conventions were followed when generating the file). The most common formats to store/exchange data sets as the ones we usually handle in biological sciences are txt, csv and xls/xlsx.\n \nThe most commonly used function to import data in R is read.table. The documentation of this function actually includes all the default functions for inputting data:\n\n\nCode\n?read.table\n\n\n \n\n \nReading .txt files\n.txt files can be read using read.table. Let’s first download a freely available data set in .txt format:\n\n\nCode\n# set working directory\nsetwd(\"PUT THE FOLDER LOCATION WHERE YOU WANT TO SAVE THE FILE HERE\")\n\ndownload.file(\"http://esapubs.org/archive/ecol/E090/184/PanTHERIA_1-0_WR93_Aug2008.txt\", destfile = \"pantheria_mammals_data.txt\")\n\n\nYou can also manually download the file from here\n \nThe file can be input into R as follows:\n\n\nCode\n# read file\npntr_dt &lt;- read.table(\"pantheria_mammals_data.txt\", stringsAsFactors = FALSE, sep = \"\\t\", header = TRUE)\n\n\n\n\nCode\n# check structure\nhead(pntr_dt)\n\n\n\n\n\n\n\n\nMSW93_Order\nMSW93_Family\nMSW93_Genus\nMSW93_Species\nMSW93_Binomial\nX1.1_ActivityCycle\n\n\n\n\nRodentia\nMuridae\nAbditomys\nlatidens\nAbditomys latidens\n-999\n\n\nRodentia\nMuridae\nAbrawayaomys\nruschii\nAbrawayaomys ruschii\n-999\n\n\nRodentia\nAbrocomidae\nAbrocoma\nbennettii\nAbrocoma bennettii\n1\n\n\nRodentia\nAbrocomidae\nAbrocoma\nboliviensis\nAbrocoma boliviensis\n-999\n\n\nRodentia\nAbrocomidae\nAbrocoma\ncinerea\nAbrocoma cinerea\n-999\n\n\nChiroptera\nPteropodidae\nAcerodon\ncelebensis\nAcerodon celebensis\n-999\n\n\n\n\n\n\n\n\n\n\n\n\nX5.1_AdultBodyMass_g\nX8.1_AdultForearmLen_mm\nX13.1_AdultHeadBodyLen_mm\nX2.1_AgeatEyeOpening_d\n\n\n\n\n268\n-999.00\n223.99\n-999\n\n\n63\n-999.00\n-999.00\n-999\n\n\n251\n-999.00\n-999.00\n-999\n\n\n158\n-999.00\n-999.00\n-999\n\n\n194\n-999.00\n-999.00\n-999\n\n\n382\n133.49\n201.55\n-999\n\n\n\n\n\n\n\n\n \nThe file name is quoted and contains the file extension.\n \nNote that the value -999 is used to define empty cells. We can read this values as NAs while importing the data using the ‘na.strings’ argument:\n\n\nCode\n# read file\npntr_dt &lt;- read.table(\"pantheria_mammals_data.txt\", sep = \"\\t\", header = TRUE, na.strings = \"-999\")\n\n# check structure\nhead(pntr_dt)\n\n\n\n\n\n\n\n\nMSW93_Order\nMSW93_Family\nMSW93_Genus\nMSW93_Species\nMSW93_Binomial\nX1.1_ActivityCycle\n\n\n\n\nRodentia\nMuridae\nAbditomys\nlatidens\nAbditomys latidens\nNA\n\n\nRodentia\nMuridae\nAbrawayaomys\nruschii\nAbrawayaomys ruschii\nNA\n\n\nRodentia\nAbrocomidae\nAbrocoma\nbennettii\nAbrocoma bennettii\n1\n\n\nRodentia\nAbrocomidae\nAbrocoma\nboliviensis\nAbrocoma boliviensis\nNA\n\n\nRodentia\nAbrocomidae\nAbrocoma\ncinerea\nAbrocoma cinerea\nNA\n\n\nChiroptera\nPteropodidae\nAcerodon\ncelebensis\nAcerodon celebensis\nNA\n\n\n\n\n\n\n\n\n\n\n\n\nX5.1_AdultBodyMass_g\nX8.1_AdultForearmLen_mm\nX13.1_AdultHeadBodyLen_mm\nX2.1_AgeatEyeOpening_d\n\n\n\n\n268\nNA\n223.99\nNA\n\n\n63\nNA\nNA\nNA\n\n\n251\nNA\nNA\nNA\n\n\n158\nNA\nNA\nNA\n\n\n194\nNA\nNA\nNA\n\n\n382\n133.49\n201.55\nNA\n\n\n\n\n\n\n\n\n \nReading .csv files\nAgain, we can download an example file online:\n\n\nCode\ndownload.file(\"http://www.birds.cornell.edu/clementschecklist/wp-content/uploads/2013/03/eBird_Taxonomy_v2017_18Aug2017.csv\", destfile = \"clements_bird_list.csv\")\n\nclm_lst &lt;- read.csv(\"clements_bird_list.csv\", stringsAsFactors = FALSE)\n\nhead(clm_lst)\n\n\n\n\n\n\n\n\nTAXON_ORDER\nCATEGORY\nSPECIES_CODE\nPRIMARY_COM_NAME\nSCI_NAME\n\n\n\n\n3\nspecies\nostric2\nCommon Ostrich\nStruthio camelus\n\n\n5\nspecies\nostric3\nSomali Ostrich\nStruthio molybdophanes\n\n\n6\nslash\ny00934\nCommon/Somali Ostrich\nStruthio camelus/molybdophanes\n\n\n7\nspecies\ngrerhe1\nGreater Rhea\nRhea americana\n\n\n13\nspecies\nlesrhe2\nLesser Rhea\nRhea pennata\n\n\n14\nissf\nlesrhe4\nLesser Rhea (Puna)\nRhea pennata tarapacensis/garleppi\n\n\n\n\n\n\n\n\n\n\n\n\nORDER1\nFAMILY\nSPECIES_GROUP\nREPORT_AS\n\n\n\n\nStruthioniformes\nStruthionidae (Ostriches)\nOstriches\n\n\n\nStruthioniformes\nStruthionidae (Ostriches)\n\n\n\n\nStruthioniformes\nStruthionidae (Ostriches)\n\n\n\n\nRheiformes\nRheidae (Rheas)\nRheas\n\n\n\nRheiformes\nRheidae (Rheas)\n\n\n\n\nRheiformes\nRheidae (Rheas)\n\nlesrhe2\n\n\n\n\n\n\n\n\nYou can also manually download the file from here\n \nAs in the previous example, we can tell R how to identify empty cells using the ‘na.strings’ argument:\n\n\nCode\nclm_lst &lt;- read.csv(\"clements_bird_list.csv\", stringsAsFactors = FALSE, na.strings = \"\")\n\nhead(clm_lst)\n\n\n\n\n\n\n\n\nTAXON_ORDER\nCATEGORY\nSPECIES_CODE\nPRIMARY_COM_NAME\nSCI_NAME\n\n\n\n\n3\nspecies\nostric2\nCommon Ostrich\nStruthio camelus\n\n\n5\nspecies\nostric3\nSomali Ostrich\nStruthio molybdophanes\n\n\n6\nslash\ny00934\nCommon/Somali Ostrich\nStruthio camelus/molybdophanes\n\n\n7\nspecies\ngrerhe1\nGreater Rhea\nRhea americana\n\n\n13\nspecies\nlesrhe2\nLesser Rhea\nRhea pennata\n\n\n14\nissf\nlesrhe4\nLesser Rhea (Puna)\nRhea pennata tarapacensis/garleppi\n\n\n\n\n\n\n\n\n\n\n\n\nORDER1\nFAMILY\nSPECIES_GROUP\nREPORT_AS\n\n\n\n\nStruthioniformes\nStruthionidae (Ostriches)\nOstriches\nNA\n\n\nStruthioniformes\nStruthionidae (Ostriches)\nNA\nNA\n\n\nStruthioniformes\nStruthionidae (Ostriches)\nNA\nNA\n\n\nRheiformes\nRheidae (Rheas)\nRheas\nNA\n\n\nRheiformes\nRheidae (Rheas)\nNA\nNA\n\n\nRheiformes\nRheidae (Rheas)\nNA\nlesrhe2"
  },
  {
    "objectID": "importing_data.html#reading-excel-files",
    "href": "importing_data.html#reading-excel-files",
    "title": "Importing and formatting data",
    "section": "2.3 Reading excel files",
    "text": "2.3 Reading excel files\nMost researchers enter data into excel spreadsheets. So it would be pretty handy to read the data directly from there. To read xls and xlsx files we need to install the package “readxl” (there are other packages that can be used but they all work similarly):\n\n\nCode\ninstall.packages(pkgs = \"readxl\")\n\n\n \nAnd load it:\n\n\nCode\nlibrary(readxl)\n\n\n \nAs we did above, download an example file from an online repository. In this case is the same Clements bird taxonomy list in xlsx format:\n\n\nCode\ndownload.file(\"http://www.birds.cornell.edu/clementschecklist/wp-content/uploads/2017/08/eBird_Taxonomy_v2017_18Aug2017.xlsx\", destfile = \"clements_bird_list.xlsx\")\n\n\nYou can also manually download the file from here\n \nNow we can use the function read_excel() to read the file:\n\n\nCode\n# read file\nclm_lst2 &lt;- read_excel(\"clements_bird_list.xlsx\", sheet = 1)\n\nhead(clm_lst2)\n\n\n\n\n\n\n\n\nTAXON_ORDER\nCATEGORY\nSPECIES_CODE\nPRIMARY_COM_NAME\nSCI_NAME\n\n\n\n\n3\nspecies\nostric2\nCommon Ostrich\nStruthio camelus\n\n\n5\nspecies\nostric3\nSomali Ostrich\nStruthio molybdophanes\n\n\n6\nslash\ny00934\nCommon/Somali Ostrich\nStruthio camelus/molybdophanes\n\n\n7\nspecies\ngrerhe1\nGreater Rhea\nRhea americana\n\n\n13\nspecies\nlesrhe2\nLesser Rhea\nRhea pennata\n\n\n14\nissf\nlesrhe4\nLesser Rhea (Puna)\nRhea pennata tarapacensis/garleppi\n\n\n\n\n\n\n\n\n\n\n\n\nORDER1\nFAMILY\nSPECIES_GROUP\nREPORT_AS\n\n\n\n\nStruthioniformes\nStruthionidae (Ostriches)\nOstriches\nNA\n\n\nStruthioniformes\nStruthionidae (Ostriches)\nNA\nNA\n\n\nStruthioniformes\nStruthionidae (Ostriches)\nNA\nNA\n\n\nRheiformes\nRheidae (Rheas)\nRheas\nNA\n\n\nRheiformes\nRheidae (Rheas)\nNA\nNA\n\n\nRheiformes\nRheidae (Rheas)\nNA\nlesrhe2\n\n\n\n\n\n\n\n\n \nYou need to specify the file name (including extension) and the excel sheet (tab) name. read_excel() auto detects the format from the file extension. The functions read_xls() and read_xlsx() can be used to read files without extension.\n \n\nExercise 1\nAll default functions to input data into R have a counterpart to export the same type of data. The names of these other functions are similar to the ones for reading data, although they typically start with “write” or “save”.\n\n1.1 What are the names of the default functions for exporting the data formats we used above? (hint: try apropos to check which functions are available)\n\n1.2 Export the mammals data as a .csv file\n\n1.3 Export the mammals data again, this time excluding the row names\n\n1.4 Read the .csv file using read.table\n\n1.5 What other packages can import excel files into R?\n\n1.6 Can you export an excel file or add data to an existing excel file from R?\n\n1.7 Using the “clements_bird_list.csv” file, how would you tell R to read both “Rheiformes” and “Ostriches” as empty cells (while still reading empty cells as empty cells)?"
  },
  {
    "objectID": "importing_data.html#tidy-data",
    "href": "importing_data.html#tidy-data",
    "title": "Importing and formatting data",
    "section": "3.1 Tidy data",
    "text": "3.1 Tidy data\n“Tidy data” is a logic for organizing data sets in a consistent and intuitive way. To run some of the code below you will need the ‘tidyr’ and ‘dplyr’ packages, which can be installed/loaded as follows:\n\n\nCode\ninstall.packages(pkgs = \"tidyr\")\n\ninstall.packages(pkgs = \"dplyr\")\n\nlibrary(tidyr)\n\nlibrary(dplyr)\n\n\n \nThe same data can be represented in many ways. In the example below each data set shows exactly the same values of four variables country, year, population, and cases, but in each data set values are organized in a different way. The data shows the number of tuberculosis cases in Afghanistan, Brazil, and China between 1999 and 2000:\n\n\nCode\nas.data.frame(table1)\n\n\n\n\n\n\n\n\ncountry\nyear\ncases\npopulation\n\n\n\n\nAfghanistan\n1999\n745\n19987071\n\n\nAfghanistan\n2000\n2666\n20595360\n\n\nBrazil\n1999\n37737\n172006362\n\n\nBrazil\n2000\n80488\n174504898\n\n\nChina\n1999\n212258\n1272915272\n\n\nChina\n2000\n213766\n1280428583\n\n\n\n\n\n\n\n\n\n\nCode\nas.data.frame(table2)\n\n\n\n\n\n\n\n\ncountry\nyear\ntype\ncount\n\n\n\n\nAfghanistan\n1999\ncases\n745\n\n\nAfghanistan\n1999\npopulation\n19987071\n\n\nAfghanistan\n2000\ncases\n2666\n\n\nAfghanistan\n2000\npopulation\n20595360\n\n\nBrazil\n1999\ncases\n37737\n\n\nBrazil\n1999\npopulation\n172006362\n\n\nBrazil\n2000\ncases\n80488\n\n\nBrazil\n2000\npopulation\n174504898\n\n\nChina\n1999\ncases\n212258\n\n\nChina\n1999\npopulation\n1272915272\n\n\nChina\n2000\ncases\n213766\n\n\nChina\n2000\npopulation\n1280428583\n\n\n\n\n\n\n\n\n\n\nCode\nas.data.frame(table3)\n\n\n\n\n\n\n\n\ncountry\nyear\nrate\n\n\n\n\nAfghanistan\n1999\n745/19987071\n\n\nAfghanistan\n2000\n2666/20595360\n\n\nBrazil\n1999\n37737/172006362\n\n\nBrazil\n2000\n80488/174504898\n\n\nChina\n1999\n212258/1272915272\n\n\nChina\n2000\n213766/1280428583\n\n\n\n\n\n\n\n\nOr even spread across 2 different data sets:\n\n\nCode\nas.data.frame(table4a)\n\n\n\n\n\n\n\n\ncountry\n1999\n2000\n\n\n\n\nAfghanistan\n745\n2666\n\n\nBrazil\n37737\n80488\n\n\nChina\n212258\n213766\n\n\n\n\n\n\n\n\n\n\nCode\nas.data.frame(table4b)\n\n\n\n\n\n\n\n\ncountry\n1999\n2000\n\n\n\n\nAfghanistan\n19987071\n20595360\n\n\nBrazil\n172006362\n174504898\n\n\nChina\n1272915272\n1280428583\n\n\n\n\n\n\n\n\n \nAll these data sets contained the same underlying data. However, they are not equally easy to use.\nThere are three interrelated rules to make a data set tidy:\n\nEach variable must have its own column\nEach observation must have its own row\nEach value must have its own cell\n\nThis figure shows the rules visually:\n * Modified from R for Data Science  \nThese three rules are interrelated because it’s impossible to only satisfy two of the three. That interrelationship leads to an even simpler set of practical instructions:\n\nPut each data set in a data frame\nPut each variable in a column\n\n \nIn the example above, only table1 is tidy. It’s the only representation where each column is a variable. There are two main advantages of formatting the data in this way:\n\nIf you have a consistent data structure, it’s easier to learn the tools that work with it because they have an underlying uniformity\nPlacing variables in columns fits well R’s vectorized nature. As we have seen, built-in R functions work with vectors of values. That makes transforming tidy data feel particularly natural\n\n \n\nExercise 2\n\n2.1 Describe how the variables and observations are organized in each of the sample data frames\n\n2.2 Calculate the rate of cases per 10000 people for “table1”, “table2” and “table4a”/“table4b”"
  },
  {
    "objectID": "importing_data.html#gathering-data",
    "href": "importing_data.html#gathering-data",
    "title": "Importing and formatting data",
    "section": "3.2 Gathering data",
    "text": "3.2 Gathering data\nA common problem is a data set where some of the column names are not names of variables, but values of a variable. Take “table4a”: the column names 1999 and 2000 represent values of the year variable, and each row represents two observations, not one:\n\n\nCode\nas.data.frame(table4a)\n\n\n\n\n\n\n\n\ncountry\n1999\n2000\n\n\n\n\nAfghanistan\n745\n2666\n\n\nBrazil\n37737\n80488\n\n\nChina\n212258\n213766\n\n\n\n\n\n\n\n\n \nTo tidy a data set like this, we need to gather those columns into a new pair of variables. To do this we need three parameters:\n\nThe set of columns that represent values, not variables. In this example, those are the columns 1999 and 2000\nThe name of the variable whose values form the column names. In the ‘tidyr’ syntax that is called the key, which in this case is year\nThe name of the variable whose values are spread over the cells. In the ‘tidyr’ syntax that is called that value, which in this case is the number of cases\n\nThese parameters can be used to create a tidy data set using the function gather():\n\n\nCode\ngather(table4a, key = \"year\", value = \"cases\", `1999`, `2000`)\n\n\n\n\n\n\n\n\ncountry\nyear\ncases\n\n\n\n\nAfghanistan\n1999\n745\n\n\nBrazil\n1999\n37737\n\n\nChina\n1999\n212258\n\n\nAfghanistan\n2000\n2666\n\n\nBrazil\n2000\n80488\n\n\nChina\n2000\n213766\n\n\n\n\n\n\n\n\nWe can visualize this formatting as follows:\n * Modified from R for Data Science  \ngather() can also be used to tidy table4b. The only difference is the variable stored in the cell values:\n\n\nCode\ngather(data = table4b, key = \"year\", value = \"population\", `1999`, `2000`)\n\n\n\n\n\n\n\n\ncountry\nyear\npopulation\n\n\n\n\nAfghanistan\n1999\n19987071\n\n\nBrazil\n1999\n172006362\n\n\nChina\n1999\n1272915272\n\n\nAfghanistan\n2000\n20595360\n\n\nBrazil\n2000\n174504898\n\n\nChina\n2000\n1280428583\n\n\n\n\n\n\n\n\n \nTo combine the tidied versions of table4a and table4b into a single data frame (or ‘tibble’), we can either use dplyr::left_join() or merge() from base R:\n\n\nCode\ntidy4a &lt;- gather(table4a, key = \"year\", value = \"cases\", `1999`, `2000`)\n\ntidy4b &lt;- gather(table4b, key = \"year\", value = \"population\", `1999`, `2000`)\n\nleft_join(x = tidy4a, y = tidy4b, by = c(\"country\", \"year\"))\n\n\n\n\n\n\n\n\ncountry\nyear\ncases\npopulation\n\n\n\n\nAfghanistan\n1999\n745\n19987071\n\n\nBrazil\n1999\n37737\n172006362\n\n\nChina\n1999\n212258\n1272915272\n\n\nAfghanistan\n2000\n2666\n20595360\n\n\nBrazil\n2000\n80488\n174504898\n\n\nChina\n2000\n213766\n1280428583\n\n\n\n\n\n\n\n\n \n\n\nCode\nmerge(x = tidy4a, y =  tidy4b, by = c(\"country\", \"year\"))\n\n\n\n\n\n\n\n\ncountry\nyear\ncases\npopulation\n\n\n\n\nAfghanistan\n1999\n745\n19987071\n\n\nAfghanistan\n2000\n2666\n20595360\n\n\nBrazil\n1999\n37737\n172006362\n\n\nBrazil\n2000\n80488\n174504898\n\n\nChina\n1999\n212258\n1272915272\n\n\nChina\n2000\n213766\n1280428583"
  },
  {
    "objectID": "importing_data.html#spreading",
    "href": "importing_data.html#spreading",
    "title": "Importing and formatting data",
    "section": "3.3 Spreading",
    "text": "3.3 Spreading\nSpreading is the opposite of gathering. You use it when an observation is scattered across multiple rows. For example, in table2 an observation is a country in a year, but each observation is spread across two rows:\n\n\nCode\ntable2\n\n\n\n\n\n\n\n\ncountry\nyear\ntype\ncount\n\n\n\n\nAfghanistan\n1999\ncases\n745\n\n\nAfghanistan\n1999\npopulation\n19987071\n\n\nAfghanistan\n2000\ncases\n2666\n\n\nAfghanistan\n2000\npopulation\n20595360\n\n\nBrazil\n1999\ncases\n37737\n\n\nBrazil\n1999\npopulation\n172006362\n\n\nBrazil\n2000\ncases\n80488\n\n\nBrazil\n2000\npopulation\n174504898\n\n\nChina\n1999\ncases\n212258\n\n\nChina\n1999\npopulation\n1272915272\n\n\nChina\n2000\ncases\n213766\n\n\nChina\n2000\npopulation\n1280428583\n\n\n\n\n\n\n\n\n \nTo tidy this data set up, we only need two parameters:\n\nThe column that contains variable names, the key column. Here, it’s type.\nThe column that contains values forms multiple variables, the value column. Here it’s count.\n\n \nTo do this we can use spread():\n\n\nCode\nspread(table2, key = \"type\", value = \"count\")\n\n\n\n\n\n\n\n\ncountry\nyear\ncases\npopulation\n\n\n\n\nAfghanistan\n1999\n745\n19987071\n\n\nAfghanistan\n2000\n2666\n20595360\n\n\nBrazil\n1999\n37737\n172006362\n\n\nBrazil\n2000\n80488\n174504898\n\n\nChina\n1999\n212258\n1272915272\n\n\nChina\n2000\n213766\n1280428583\n\n\n\n\n\n\n\n\n \nwhich can be visualized as follows:\n * Modified from R for Data Science  \nspread() and gather() are complementary functions. gather() makes wide tables narrower and longer; spread() makes long tables shorter and wider.\n \n\nExercise 3\n\n3.1 Tidy up the following data set on tree height for 2 species:\n\n\nCode\nplnt_sz &lt;- data.frame(forest = c(\"old_growth\", \"disturbed\"), \n                      Species_1 = c(154, 160), \n                      Species_2 = c(120, 113))\n\n\n\n \n\nSeparating and uniting\nSo far we have fixed “table2” and “table4”, but not “table3”. “table3” has a different problem: we have one column (rate) that contains two variables (cases and population*). This can be fixed using the separate() function . We will also look at its complementunite(), which is used when a single variable is spread across multiple columns."
  },
  {
    "objectID": "importing_data.html#separate",
    "href": "importing_data.html#separate",
    "title": "Importing and formatting data",
    "section": "3.4 Separate",
    "text": "3.4 Separate\nseparate() pulls apart one column into multiple columns, by splitting wherever a separator character appears. Take table3:\n\n\nCode\nas.data.frame(table3)\n\n\n\n\n\n\n\n\ncountry\nyear\nrate\n\n\n\n\nAfghanistan\n1999\n745/19987071\n\n\nAfghanistan\n2000\n2666/20595360\n\n\nBrazil\n1999\n37737/172006362\n\n\nBrazil\n2000\n80488/174504898\n\n\nChina\n1999\n212258/1272915272\n\n\nChina\n2000\n213766/1280428583\n\n\n\n\n\n\n\n\nVisually it does something like this:\n * Modified from R for Data Science\n \nThe rate column contains both cases and population variables, and we need to split it into two variables. separate() takes the name of the column to separate, and the names of the new columns to be created:\n\n\nCode\nseparate(data = table3, col =  rate, into = c(\"cases\", \"population\"))\n\n\n\n\n\n\n\n\ncountry\nyear\ncases\npopulation\n\n\n\n\nAfghanistan\n1999\n745\n19987071\n\n\nAfghanistan\n2000\n2666\n20595360\n\n\nBrazil\n1999\n37737\n172006362\n\n\nBrazil\n2000\n80488\n174504898\n\n\nChina\n1999\n212258\n1272915272\n\n\nChina\n2000\n213766\n1280428583\n\n\n\n\n\n\n\n\nBy default, separate() will split based on any non-alphanumeric character (i.e. a character that isn’t a number or letter). In the code above, separate() split the values of rate at the forward slash characters. This can be explicitly stated (to avoid any errors):\n\n\nCode\ntb3 &lt;- separate(data = table3, col = rate,  into = c(\"cases\", \"population\"), sep = \"/\")\n\ntb3 \n\n\n\n\n\n\n\n\ncountry\nyear\ncases\npopulation\n\n\n\n\nAfghanistan\n1999\n745\n19987071\n\n\nAfghanistan\n2000\n2666\n20595360\n\n\nBrazil\n1999\n37737\n172006362\n\n\nBrazil\n2000\n80488\n174504898\n\n\nChina\n1999\n212258\n1272915272\n\n\nChina\n2000\n213766\n1280428583\n\n\n\n\n\n\n\n\ntibble [6 × 4] (S3: tbl_df/tbl/data.frame)\n $ country   : chr [1:6] \"Afghanistan\" \"Afghanistan\" \"Brazil\" \"Brazil\" ...\n $ year      : num [1:6] 1999 2000 1999 2000 1999 ...\n $ cases     : chr [1:6] \"745\" \"2666\" \"37737\" \"80488\" ...\n $ population: chr [1:6] \"19987071\" \"20595360\" \"172006362\" \"174504898\" ...\n\n\n \nNote that the case and population are character columns. By default separate() leaves the type of the new columns as in the original one. In this case this is not ideal as those really are numbers. We can ask separate() to try and convert to better types using convert = TRUE:\n\n\nCode\ntb3 &lt;- separate(data = table3, col = rate, into = c(\"cases\", \"population\"), convert = TRUE)\n\nstr(tb3)\n\n\ntibble [6 × 4] (S3: tbl_df/tbl/data.frame)\n $ country   : chr [1:6] \"Afghanistan\" \"Afghanistan\" \"Brazil\" \"Brazil\" ...\n $ year      : num [1:6] 1999 2000 1999 2000 1999 ...\n $ cases     : int [1:6] 745 2666 37737 80488 212258 213766\n $ population: int [1:6] 19987071 20595360 172006362 174504898 1272915272 1280428583\n\n\n \nYou can also pass a vector of integers to sep, which will be interpreted as positions to split at. Positive values start at 1 on the far-left of the strings; negative value start at -1 on the far-right of the strings. When using integers to separate strings, the length of sep should be one less than the number of names in into. You can use this to separate the last two digits of each year:\n\n\nCode\nseparate(data = table3, col = year, into = c(\"century\", \"year\"), \n         sep = 2)\n\n\n\n\n\n\n\n\ncountry\ncentury\nyear\nrate\n\n\n\n\nAfghanistan\n19\n99\n745/19987071\n\n\nAfghanistan\n20\n00\n2666/20595360\n\n\nBrazil\n19\n99\n37737/172006362\n\n\nBrazil\n20\n00\n80488/174504898\n\n\nChina\n19\n99\n212258/1272915272\n\n\nChina\n20\n00\n213766/1280428583\n\n\n\n\n\n\n\n\nSeparating columns can also be done with base R, although it takes a bit more coding:\n\n\nCode\ntable3$cases &lt;- sapply(table3$rate, function(x) try(strsplit(x, \"/\")[[1]][1]), USE.NAMES = FALSE)\n\ntable3$population &lt;- sapply(table3$rate, function(x) try(strsplit(x, \"/\")[[1]][2]), USE.NAMES = FALSE)\n\ntb3 \n\n\n\n\n\n\n\n\ncountry\nyear\nrate\ncases\npopulation\n\n\n\n\nAfghanistan\n1999\n745/19987071\n745\n19987071\n\n\nAfghanistan\n2000\n2666/20595360\n2666\n20595360\n\n\nBrazil\n1999\n37737/172006362\n37737\n172006362\n\n\nBrazil\n2000\n80488/174504898\n80488\n174504898\n\n\nChina\n1999\n212258/1272915272\n212258\n1272915272\n\n\nChina\n2000\n213766/1280428583\n213766\n1280428583\n\n\n\n\n\n\n\n\ntibble [6 × 4] (S3: tbl_df/tbl/data.frame)\n $ country   : chr [1:6] \"Afghanistan\" \"Afghanistan\" \"Brazil\" \"Brazil\" ...\n $ year      : num [1:6] 1999 2000 1999 2000 1999 ...\n $ cases     : chr [1:6] \"745\" \"2666\" \"37737\" \"80488\" ...\n $ population: chr [1:6] \"19987071\" \"20595360\" \"172006362\" \"174504898\" ..."
  },
  {
    "objectID": "importing_data.html#unite",
    "href": "importing_data.html#unite",
    "title": "Importing and formatting data",
    "section": "3.5 Unite",
    "text": "3.5 Unite\nunite() is the inverse of separate(): combining multiple columns into a single column:\n * Modified from R for Data Science\n \nHowever, you will need it much less frequently than separate().\nWe can use unite() to rejoin the century and year columns that we created above:\n\n\nCode\nunite(data = table5, col = \"new\", \"century\", \"year\")\n\n\n\n\n\n\n\n\ncountry\nnew\nrate\n\n\n\n\nAfghanistan\n19_99\n745/19987071\n\n\nAfghanistan\n20_00\n2666/20595360\n\n\nBrazil\n19_99\n37737/172006362\n\n\nBrazil\n20_00\n80488/174504898\n\n\nChina\n19_99\n212258/1272915272\n\n\nChina\n20_00\n213766/1280428583\n\n\n\n\n\n\n\n\nIn this function we can also use the sep argument (although in this example it was not specified).\n \n\nExercise 3\n\n3.1 Unite century and year in “table5” using base R (hint: paste())"
  },
  {
    "objectID": "r_basics.html",
    "href": "r_basics.html",
    "title": "Basic elements of the R language",
    "section": "",
    "text": "To understand the basic blocks used in R programming\nTo become familiar with the main sources of standardized documentation in R"
  },
  {
    "objectID": "r_basics.html#section",
    "href": "r_basics.html#section",
    "title": "Basic elements of the R language",
    "section": "2.1  ",
    "text": "2.1"
  },
  {
    "objectID": "r_basics.html#objects-containing-data",
    "href": "r_basics.html#objects-containing-data",
    "title": "Basic elements of the R language",
    "section": "3.1 Objects containing data",
    "text": "3.1 Objects containing data\nThe basic data structure in R is the vector. With this all other object classes are built. To understand classes it is useful to think about the number of dimensions (1, 2 or more) and types of data they can contain: homogeneous (a single element type) or heterogeneous (or multiple element types).\n\n\n\n\n\nflowchart LR\n    classDef largeText font-size:18px, padding:15px;\n\n    D(Data objects) --&gt; D1(1 dimension)\n    D --&gt; D2(2 dimensions)\n    D1 --&gt; V(Vector)\n    D1 --&gt; L(List)\n    D2 --&gt; M(Matrix)\n    D2 --&gt;  DF(Data Frame)\n\n    style D fill:#40498E66, stroke:#000, stroke-width:2px, color:#FFF, width:180px\n    style D1 fill:#348AA666, stroke:#000, stroke-width:2px, color:#FFF, width:140px\n    style D2 fill:#348AA666, stroke:#000, stroke-width:2px, color:#FFF, width:140px\n    style DF fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style V fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style M fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style L fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHomogeneous\nHeterogeneous\n\n\n\n\n1d\nAtomic vector\nList\n\n\n2d\nMatrix\nData frame\n\n\nnd\nArray\n\n\n\n\n\n\n\n\n3.1.1 1 dimension objects\nThere are two basic types of vectors: atomic vectors and lists.\nThey have three common properties:\n\nType, typeof() (class/mode).\nLength, length() (number of elements)\nAttributes, attributes() (metadata)\n\nThey differ in the types of their elements: all elements of an atomic vector must be of the same type, while the elements of a list can have different types.\n\n3.1.1.1 Atomic vectors\nTypes of atomic vectors:\n\nLogical (Boolean)\nInteger\nNumeric (double)\nCharacters\nFactors\n\nVectors are constructed with the c() function, they can be numeric:\n\n\nCode\nx &lt;- 1\nx1 &lt;- c(1)\n\nall.equal(x, x1)\n\n\n[1] TRUE\n\n\nCode\nclass(x)\n\n\n[1] \"numeric\"\n\n\nCharacters:\n\n\nCode\ny &lt;- \"something\"\n\nclass(y)\n\n\n[1] \"character\"\n\n\nLogical:\n\n\nCode\nz &lt;- TRUE\n\nclass(z)\n\n\n[1] \"logical\"\n\n\nOr factor:\n\n\nCode\nq &lt;- factor(1)\n\nclass(q)\n\n\n[1] \"factor\"\n\n\nTherefore, the individual numbers or strings are actually vectors of length one:\n\n\nCode\nclass(1)\n\n\n[1] \"numeric\"\n\n\nCode\nclass(\"a\")\n\n\n[1] \"character\"\n\n\nVectors can only contain elements of the same type. Different types of elements will be forced to the most flexible type:\n\n\nCode\nx &lt;- c(1, 2, \"a\")\n\nx\n\n\n[1] \"1\" \"2\" \"a\"\n\n\nCode\nclass(x)\n\n\n[1] \"character\"\n\n\nMissing values are specified with NA, which is a logical vector of length 1. NA will always be interpreted to the correct type if used inside c():\n\n\nCode\nv &lt;- c(10, 11, NA)\n\nclass(v)\n\n\n[1] \"numeric\"\n\n\nCode\nv &lt;- c(\"a\", \"b\", NA)\n\nclass(v)\n\n\n[1] \"character\"\n\n\n\n\n\n3.1.1.2 Factors\nVectors with factors are very similar to character vectors. However, a factor can only contain predefined values, known as levels. Attributes are used to define the levels of the factor.\nFactors are built on integer vectors using two attributes:\n\n“factor” class: makes them behave differently from normal character vectors.\nlevels: defines the set of allowed values\n\n\n\nCode\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n\n\n[1] a b b a\nLevels: a b\n\n\nCode\nlevels(x)\n\n\n[1] \"a\" \"b\"\n\n\nCode\nstr(x)\n\n\n Factor w/ 2 levels \"a\",\"b\": 1 2 2 1\n\n\nThe factors look like character vectors, but are actually integers:\n\n\nCode\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\n\nc(x)\n\n\n[1] a b b a\nLevels: a b\n\n\n\n\n3.1.1.3 Lists\nCan contain objects of different classes and sizes. Lists are constructed with list():\n\n\nCode\nl &lt;- list(\"a\", 1, FALSE)\n\nl\n\n\n[[1]]\n[1] \"a\"\n\n[[2]]\n[1] 1\n\n[[3]]\n[1] FALSE\n\n\nCode\nclass(l)\n\n\n[1] \"list\"\n\n\nCode\nstr(l)\n\n\nList of 3\n $ : chr \"a\"\n $ : num 1\n $ : logi FALSE\n\n\nIn fact, they can be seen as drawers where you can put any other type of object:\n\n\nCode\nl &lt;- list(c(\"a\", \"b\"), \n          c(1, 2, 3, 4), \n          c(FALSE, TRUE, FALSE))\n\nl\n\n\n[[1]]\n[1] \"a\" \"b\"\n\n[[2]]\n[1] 1 2 3 4\n\n[[3]]\n[1] FALSE  TRUE FALSE\n\n\nCode\nstr(l)\n\n\nList of 3\n $ : chr [1:2] \"a\" \"b\"\n $ : num [1:4] 1 2 3 4\n $ : logi [1:3] FALSE TRUE FALSE\n\n\n\n\n\n3.1.2 2-dimensional objects\n\n3.1.2.1 Matrices\nAll elements are of the same type:\n\n\nCode\nm &lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2)\n\ndim(m)\n\n\n[1] 2 3\n\n\nCode\nm\n\n\n     [,1] [,2] [,3]\n[1,]    1    3   12\n[2,]    2   11   13\n\n\nCode\nclass(m)\n\n\n[1] \"matrix\" \"array\" \n\n\nCode\nm &lt;- matrix(c(1, 2, 3, 11, 12, \"13\"), nrow = 2)\nm\n\n\n     [,1] [,2] [,3]\n[1,] \"1\"  \"3\"  \"12\"\n[2,] \"2\"  \"11\" \"13\"\n\n\n\n\n3.1.2.2 Data Frames\nSpecial case of lists. It can contain elements of different types:\n\n\nCode\nm &lt;-\n  data.frame(\n    ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n    size = c(1, 2, 3, 4, 5),\n    observed = c(FALSE, TRUE, FALSE, FALSE, FALSE)\n  )\n\ndim(m)\n\n\n[1] 5 3\n\n\nCode\nm\n\n\n\n\n\n\nID\nsize\nobserved\n\n\n\n\na\n1\nFALSE\n\n\nb\n2\nTRUE\n\n\nc\n3\nFALSE\n\n\nd\n4\nFALSE\n\n\ne\n5\nFALSE\n\n\n\n\n\n\nCode\nclass(m)\n\n\n[1] \"data.frame\"\n\n\nCode\nis.data.frame(m)\n\n\n[1] TRUE\n\n\nCode\nis.list(m)\n\n\n[1] TRUE\n\n\nCode\nstr(m)\n\n\n'data.frame':   5 obs. of  3 variables:\n $ ID      : chr  \"a\" \"b\" \"c\" \"d\" ...\n $ size    : num  1 2 3 4 5\n $ observed: logi  FALSE TRUE FALSE FALSE FALSE\n\n\nBut the vectors must have the same length:\n\n\nCode\nm &lt;-\n  data.frame(\n    ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n    size = c(1, 2, 3, 4, 5, 6),\n    observed = c(FALSE, TRUE, FALSE, FALSE, FALSE)\n  )\n\n\nError in data.frame(ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"), size = c(1, 2, 3, : arguments imply differing number of rows: 5, 6\n\n\n \n\n\n\n3.1.3 Exercise 1\n\nCreate a numeric vector with 8 elements containing positive and negative numbers.\nCreate a character vector with the names of the provinces of Costa Rica.\nAdd to the above point vector an NA\nCreate a numeric matrix with 3 columns and 3 rows\nCreate a character matrix with 4 columns and 3 rows\nWhat type of object is ‘iris’ and what are its dimensions (hint: iris is an object available by default in your environment)?\nCreate a data frame with a numeric column, a character column and a factor column."
  },
  {
    "objectID": "r_basics.html#functions-objects-that-perform-tasks",
    "href": "r_basics.html#functions-objects-that-perform-tasks",
    "title": "Basic elements of the R language",
    "section": "3.2 Functions: objects that perform tasks",
    "text": "3.2 Functions: objects that perform tasks\nAll functions are created with the function() function and follow the same structure:\n\n* Modified from Grolemund 2014  \n\n3.2.1 Integrated functions\n\n3.2.1.1 Basic functions\nR comes with many functions that you can use to do sophisticated tasks:\n\n\nCode\n# built in functions\nbi &lt;- builtins(internal = FALSE)\n\nlength(bi)\n\n\n[1] 1388\n\n\nSome functions come by default with R basic. New functions can be loaded as part of additional packages or even created by the user.\n\n\n\n\n\nflowchart LR\n    classDef largeText font-size:18px, padding:15px;\n\n    F(Functions) --&gt; BF(Integraded functions)\n    BF --&gt; OP(Operators)\n    BF --&gt; BA(Basic functions)\n    F --&gt; PF(Packages)\n    F --&gt; UF(User defined functions)\n\n    class R,D,D1,D2,F largeText;\n\n    style F fill:#357BA266, stroke:#000, stroke-width:2px, color:#FFF, width:120px\n    style BF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000\n    style BA fill:#DEF5E566, stroke:#000, stroke-width:2px, color:#000\n    style OP fill:#DEF5E566, stroke:#000, stroke-width:2px, color:#000    \n    style PF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000000\n    style UF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000\n\n\n\n\n\n\n\n\n\n3.2.1.2 Operators\nOperators are functions:\n\n\nCode\n1 + 1\n\n\n[1] 2\n\n\nCode\n'+'(1, 1)\n\n\n[1] 2\n\n\nCode\n2 * 3\n\n\n[1] 6\n\n\nCode\n'*'(2, 3)\n\n\n[1] 6\n\n\n\n3.2.1.2.1 Most used operators\nArithmetic operators:\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n+\nsum\n\n\n-\nsubtraction\n\n\n*\nmultiplication\n\n\n/\ndivision\n\n\n^ or **\nexponential\n\n\n\n\n\n\n\n\n\n\nCode\n1 - 2\n\n\n[1] -1\n\n\nCode\n1 + 2\n\n\n[1] 3\n\n\nCode\n2 ^ 2\n\n\n[1] 4\n\n\nCode\n2 ** 2\n\n\n[1] 4\n\n\nCode\n2:3 %in% 2:4\n\n\n[1] TRUE TRUE\n\n\nLogical operators:\n\n\n\nOperator\nDescription\n\n\n\n\n&lt;\nlower than\n\n\n&lt;=\nlower than or equal to\n\n\n&gt;\nhigher than\n\n\n&gt;=\nhigher than or equal to\n\n\n==\nexactly the same\n\n\n!=\ndifferent than\n\n\n!x\nIs not x\n\n\nx | y\nx O y\n\n\nx & y\nx Y y\n\n\nx %in% y\ncorrespondence\n\n\n\n\n\nCode\n1 &lt; 2 \n\n\n[1] TRUE\n\n\nCode\n1 &gt; 2 \n\n\n[1] FALSE\n\n\nCode\n1 &lt;= 2 \n\n\n[1] TRUE\n\n\nCode\n1 == 2\n\n\n[1] FALSE\n\n\nCode\n1 != 2\n\n\n[1] TRUE\n\n\nCode\n1 &gt; 2 \n\n\n[1] FALSE\n\n\nCode\n5 %in% 1:6\n\n\n[1] TRUE\n\n\nCode\n5 %in% 1:4\n\n\n[1] FALSE\n\n\n \n\n\n\n\n3.2.2 Vectorization\nMost functions are vectorized:\n\n\nCode\n1:6 * 1:6\n\n\n\n* Modified from Grolemund & Wickham 2017\n \n\n\n[1]  1  4  9 16 25 36\n\n\n\n\nCode\n1:6 - 1:6\n\n\n[1] 0 0 0 0 0 0\n\n\nR recycles vectors of unequal length:\n\n\nCode\n1:6 * 1:5\n\n\n\n* Modified from Grolemund & Wickham 2017\n\n \n\n3.2.3 Additional package functions\nThese are functions that are included in additional packages that can be installed and loaded into R. To be used the package must be installed and loaded, e.g. to use the corTest function of the “psych” package we must first install. The packages are installed from the CRAN (Comprehensive R Archive Network) server with the install.packages() function:\n\n\nCode\ninstall.packages(\"psych\")\n\n\n… and load the package:\n\n\nCode\nlibrary(psych)\n\n\nOnce ‘psych’ is installed and loaded, we can call the corTest function:\n\n\nCode\ncorTest(iris$Sepal.Length, iris$Sepal.Width)\n\n\nCall:corTest(x = iris$Sepal.Length, y = iris$Sepal.Width)\nCorrelation matrix \n[1] -0.12\nSample Size \n[1] 150\nThese are the unadjusted probability values.\n  The probability values  adjusted for multiple tests are in the p.adj object. \n[1] 0.15\n\n To see confidence intervals of the correlations, print with the short=FALSE option\n\n\nThe use of external packages is the most useful feature of R since it allows to make use of an almost infinite number of specialized functions in different tasks as well as in very diverse fields of science and industry.\nWe can explore the packages available for R at the CRAN website (click on the “packages” link).\n\n\n3.2.4 Exercise 2\n\nSearch for a package you are interested in on CRAN.\nInstall the package and upload it\nRun the example code of one of its functions"
  },
  {
    "objectID": "r_basics.html#object-manipulation",
    "href": "r_basics.html#object-manipulation",
    "title": "Basic elements of the R language",
    "section": "3.3 Object manipulation",
    "text": "3.3 Object manipulation"
  },
  {
    "objectID": "r_basics.html#extracting-subsets-using-indexing",
    "href": "r_basics.html#extracting-subsets-using-indexing",
    "title": "Basic elements of the R language",
    "section": "3.4 Extracting subsets using indexing",
    "text": "3.4 Extracting subsets using indexing\nElements within objects can be called by indexing. To subset a vector simply call the position of the object using square brackets:\n\n\nCode\nx &lt;- c(1, 3, 4, 10, 15, 20, 50, 1, 6)\n\nx[1]\n\n\n[1] 1\n\n\nCode\nx[2]\n\n\n[1] 3\n\n\nCode\nx[2:3]\n\n\n[1] 3 4\n\n\nCode\nx[c(1,3)]\n\n\n[1] 1 4\n\n\n \nThe elements can be removed in the same way:\n\n\nCode\nx[-1]\n\n\n[1]  3  4 10 15 20 50  1  6\n\n\nCode\nx[-c(1,3)]\n\n\n[1]  3 10 15 20 50  1  6\n\n\n \nArrays and data frames require 2 indices [row, column]:\n\n\nCode\nm &lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2)\n\nm[1, ]\n\n\n[1]  1  3 12\n\n\nCode\nm[, 1]\n\n\n[1] 1 2\n\n\nCode\nm[1, 1]\n\n\n[1] 1\n\n\nCode\nm[-1, ]\n\n\n[1]  2 11 13\n\n\nCode\nm[, -1]\n\n\n     [,1] [,2]\n[1,]    3   12\n[2,]   11   13\n\n\nCode\nm[-1, -1]\n\n\n[1] 11 13\n\n\nCode\ndf &lt;- data.frame(\n  provincia = c(\"San José\", \"Guanacaste\", \"Guanacaste\"), \n  canton = c(\"Montes de Oca\", \"Nicoya\", \"Liberia\"), \n    distrito = c(\"San Rafael\", \"Nosara\", \"Nacascolo\")\n  )\n\ndf\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\nGuanacaste\nNicoya\nNosara\n\n\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCode\ndf[1, ]\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\n\n\n\n\nCode\ndf[, 1]\n\n\n[1] \"San José\"   \"Guanacaste\" \"Guanacaste\"\n\n\nCode\ndf[1, 1]\n\n\n[1] \"San José\"\n\n\nCode\ndf[-1, ]\n\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\n2\nGuanacaste\nNicoya\nNosara\n\n\n3\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCode\ndf[, -1]\n\n\n\n\n\n\ncanton\ndistrito\n\n\n\n\nMontes de Oca\nSan Rafael\n\n\nNicoya\nNosara\n\n\nLiberia\nNacascolo\n\n\n\n\n\n\nCode\ndf[-1, -1]\n\n\n\n\n\n\n\ncanton\ndistrito\n\n\n\n\n2\nNicoya\nNosara\n\n\n3\nLiberia\nNacascolo\n\n\n\n\n\n\nCode\ndf[,\"provincia\"]\n\n\n[1] \"San José\"   \"Guanacaste\" \"Guanacaste\"\n\n\nCode\ndf[,c(\"provincia\", \"canton\")]\n\n\n\n\n\n\nprovincia\ncanton\n\n\n\n\nSan José\nMontes de Oca\n\n\nGuanacaste\nNicoya\n\n\nGuanacaste\nLiberia\n\n\n\n\n\n\n \nLists require 1 index between double square brackets [[index]]:\n\n\nCode\nl &lt;- list(c(\"a\", \"b\"),\n          c(1, 2, 3),\n          c(FALSE, TRUE, FALSE, FALSE))\n\nl[[1]]\n\n\n[1] \"a\" \"b\"\n\n\nCode\nl[[3]]\n\n\n[1] FALSE  TRUE FALSE FALSE\n\n\n \nElements within lists can also be subsets in the same code string:\n\n\nCode\nl[[1]][1:2]\n\n\n[1] \"a\" \"b\"\n\n\nCode\nl[[3]][2]\n\n\n[1] TRUE"
  },
  {
    "objectID": "r_basics.html#explore-objects",
    "href": "r_basics.html#explore-objects",
    "title": "Basic elements of the R language",
    "section": "3.5 Explore objects",
    "text": "3.5 Explore objects\nThe following basic R functions (default) can help us to explore the structure of objects:\n\n\nCode\nstr(df)\n\n\n'data.frame':   3 obs. of  3 variables:\n $ provincia: chr  \"San José\" \"Guanacaste\" \"Guanacaste\"\n $ canton   : chr  \"Montes de Oca\" \"Nicoya\" \"Liberia\"\n $ distrito : chr  \"San Rafael\" \"Nosara\" \"Nacascolo\"\n\n\nCode\nnames(df)\n\n\n[1] \"provincia\" \"canton\"    \"distrito\" \n\n\nCode\ndim(df)\n\n\n[1] 3 3\n\n\nCode\nnrow(df)\n\n\n[1] 3\n\n\nCode\nncol(df)\n\n\n[1] 3\n\n\nCode\nhead(df)\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\nGuanacaste\nNicoya\nNosara\n\n\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCode\ntail(df)\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\nGuanacaste\nNicoya\nNosara\n\n\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCode\ntable(df$provincia)\n\n\n\nGuanacaste   San José \n         2          1 \n\n\nCode\nclass(df)\n\n\n[1] \"data.frame\"\n\n\n\n\nCode\nView(df)"
  },
  {
    "objectID": "r_basics.html#exercise-3",
    "href": "r_basics.html#exercise-3",
    "title": "Basic elements of the R language",
    "section": "3.6 Exercise 3",
    "text": "3.6 Exercise 3\n\nUse the example data iris to create a subset of data with only the observations of the species setosa.\nNow create a subset of data containing the observations of both setosa and versicolor.\nAlso with iris create a subset of data with the observations for which iris$Sepal.length is greater than 6\nHow many observations have a sepal length greater than 6?"
  },
  {
    "objectID": "r_basics.html#file-names",
    "href": "r_basics.html#file-names",
    "title": "Basic elements of the R language",
    "section": "4.1 File names",
    "text": "4.1 File names\nFile names must end in .R and, of course, be self-explanatory:\n\nGood: graph_posterior_probability.R\nBad: graf.R"
  },
  {
    "objectID": "r_basics.html#object-names",
    "href": "r_basics.html#object-names",
    "title": "Basic elements of the R language",
    "section": "4.2 Object names",
    "text": "4.2 Object names\nVariables and functions:\n\nLowercase\nUse an underscore\nIn general, names for variables and verbs for functions.\nKeep names concise and meaningful (not always easy).\nAvoid using names of existing functions of variables\n\n\n\nCode\n  - Bien: dia_uno: dia_1, peso_promedio(),\n  \n  - Mal: diauno, dia1, primer.dia_delmes"
  },
  {
    "objectID": "r_basics.html#syntax",
    "href": "r_basics.html#syntax",
    "title": "Basic elements of the R language",
    "section": "4.3 Syntax",
    "text": "4.3 Syntax\n\n4.3.1 Spaces\n\nUse spaces around operators and for arguments within a function.\nAlways put a space after a comma, and never before (as in normal English).\nPlace a space before the left parenthesis, except in a function call.\n\n\n\nCode\n  - Bien: \n          a &lt;- rnorm(n = 10, sd = 10, mean = 1)\n          total &lt;- sum(x[1, ])\n\n  - Mal: \n         a&lt;-rnorm(n=10,sd=10,mean=1) \n         total &lt;- sum(x[,1])  \n\n\n \n\n4.3.1.1 Brackets\n\nThe opening key should never go on its own line.\nThe closing brace must always be on its own line.\nYou can omit braces when a block consists of only one statement\n\n\n\nCode\n  - Bien:\n              if (is.null(ylim)) {\n              ylim &lt;- c(0, 0.06)\n            }\n                      \n            if (is.null(ylim))\n              ylim &lt;- c(0, 0.06)\n          \n  - Mal:\n            \n         if (is.null(ylim)) ylim &lt;- c(0, 0.06)\n                    \n         if (is.null(ylim)) {ylim &lt;- c(0, 0.06)} \n\n         if (is.null(ylim)) {\n           ylim &lt;- c(0, 0.06)\n           } \n\n\n \n\n\n4.3.1.2 Create objects\n\nUse &lt;-, instead of =\n\n\n\nCode\n  - GOOD:\n         x &lt;- 5 \n          \n  - BAD:\n         x = 5\n\n\n \n\n\n4.3.1.3 Suggestions to add comments\n\nComment your code\nEntire commented lines should begin with # and a space.\nShort comments can be placed after the code preceded by two spaces, #, and then a space.\n\n\n\nCode\n# Create histogram of frequency of campaigns by pct budget spent.\nhist(df$pct.spent,\n     breaks = \"scott\",  # method for choosing number of buckets\n     main   = \"Histogram: individuals per unit of time\",\n     xlab   = \"Individual count\",\n     ylab   = \"Frequency\")"
  },
  {
    "objectID": "r_basics.html#package-documentation",
    "href": "r_basics.html#package-documentation",
    "title": "Basic elements of the R language",
    "section": "5.1 Package documentation",
    "text": "5.1 Package documentation"
  },
  {
    "objectID": "r_basics.html#reference-manuals",
    "href": "r_basics.html#reference-manuals",
    "title": "Basic elements of the R language",
    "section": "5.2 Reference manuals",
    "text": "5.2 Reference manuals\nReference manuals are collections of documentation for all the functions of a package (only 1 per package):\n\ndynaSpec manual\nbaRulho manual"
  },
  {
    "objectID": "r_basics.html#documentation-of-functions",
    "href": "r_basics.html#documentation-of-functions",
    "title": "Basic elements of the R language",
    "section": "5.3 Documentation of functions",
    "text": "5.3 Documentation of functions\nAll functions (default or loaded packages) must have documentation that follows a standard format:\n\n\nCode\n?mean\n\nhelp(\"mean\")\n\n\n\nThis documentation can also be displayed in Rstudio by pressing F1 when the cursor is on the function name.\nIf you do not remember the function name try apropos():\n\n\nCode\napropos(\"mean\")\n\n\n [1] \".colMeans\"      \".rowMeans\"      \"circadian.mean\" \"circular.mean\" \n [5] \"colMeans\"       \"geometric.mean\" \"harmonic.mean\"  \"kmeans\"        \n [9] \"mean\"           \"mean.Date\"      \"mean.default\"   \"mean.difftime\" \n[13] \"mean.POSIXct\"   \"mean.POSIXlt\"   \"rowMeans\"       \"weighted.mean\" \n[17] \"winsor.mean\"    \"winsor.means\""
  },
  {
    "objectID": "r_basics.html#vignettes-vignettes",
    "href": "r_basics.html#vignettes-vignettes",
    "title": "Basic elements of the R language",
    "section": "5.4 Vignettes (vignettes)",
    "text": "5.4 Vignettes (vignettes)\nVignettes are illustrative documents or case studies detailing the use of a package (optional, can be several per package).\nVignettes can be called directly from R:\n\n\nCode\nvgn &lt;- browseVignettes() \n\n\n\n\nCode\nvignette()\n\n\nTambién deberían aparecer en la página del paquete en CRAN."
  },
  {
    "objectID": "r_basics.html#exercise-4",
    "href": "r_basics.html#exercise-4",
    "title": "Basic elements of the R language",
    "section": "5.5 Exercise 4",
    "text": "5.5 Exercise 4\n\nWhat does the cut() function do?\nWhat is the breaks argument used for in cut()?\nRun the first 4 lines of code from the examples provided in the cut() documentation.\nHow many bullets does the warbleR package have?"
  },
  {
    "objectID": "r_basics.html#session-info",
    "href": "r_basics.html#session-info",
    "title": "Basic elements of the R language",
    "section": "Session info",
    "text": "Session info\n\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] psych_2.3.12\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5       nlme_3.1-155      svglite_2.1.3     cli_3.6.3        \n [5] knitr_1.48        rlang_1.1.4       xfun_0.47         stringi_1.8.4    \n [9] highr_0.11        jsonlite_1.8.8    glue_1.7.0        colorspace_2.1-1 \n[13] htmltools_0.5.8.1 scales_1.3.0      rmarkdown_2.28    grid_4.3.2       \n[17] evaluate_0.24.0   munsell_0.5.1     kableExtra_1.4.0  fastmap_1.2.0    \n[21] yaml_2.3.10       lifecycle_1.0.4   stringr_1.5.1     compiler_4.3.2   \n[25] htmlwidgets_1.6.4 rstudioapi_0.16.0 lattice_0.20-45   systemfonts_1.1.0\n[29] digest_0.6.37     viridisLite_0.4.2 R6_2.5.1          parallel_4.3.2   \n[33] mnormt_2.1.1      magrittr_2.0.3    tools_4.3.2       xml2_1.3.6"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "OTS TBCP 2024",
    "section": "",
    "text": "Stats Workshop\n\n\nOrganization For Tropical Studies\n\n\n\nMarcelo Araya-Salas, PhD\n\n\n\nSeptember, 2024\n\n\n\n\nTraditionally, statistical models have been taught as disconnected tools with no clear relationship between them. However, most of those common statistical models are just special cases of linear models. Hence, learning them as such can simplify things substantially. The course will focus on linear regression as the main tool for statistical inference. Students will be introduced to the basic elements of a linear regression model, its interpretation, as well as hands-on experience on building those models in R.\n\nObjetives\n\nUse R as the main tool for stats\nUnderstand statistical inference through a single modelling tool (broad sense linear models)\nGet familiar with building linear models\nExtend linear models to different data structures"
  }
]